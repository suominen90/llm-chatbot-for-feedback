
# retriever.py
import chromadb
from mistralai import Mistral
from typing import List
import dotenv
import os

dotenv.load_dotenv()

# create a single long-lived client (or use 'with Mistral(...) as client:' if you prefer context manager)

#print(os.getenv("MISTRAL_API_KEY"))
mistral_client = Mistral(api_key=os.getenv("MISTRAL_API_KEY"))  # will use MISTRAL_API_KEY env var if None

class VectorStore:
    def __init__(self, collection_name="docs"):
        # Chroma 0.5+ PersistentClient
        self.chroma = chromadb.PersistentClient(path="./chroma_db")
        self.collection = self.chroma.get_or_create_collection(
            name=collection_name,
            metadata={"hnsw:space": "cosine"}  # optional
        )

    def add_texts(self, texts: List[str], ids: List[str] = None):
        """
        Add a list of texts to Chroma using Mistral embeddings.
        texts: list of strings
        ids: optional list of ids matching texts; otherwise autogenerated
        """
        if not texts:
            return

        # Get embeddings in batch â€” NOTE: parameter name is `inputs`
        resp = mistral_client.embeddings.create(
            model="mistral-embed",
            inputs=texts
        )

        # resp.data is a list of objects; each has `.embedding`
        embeddings = [item.embedding for item in resp.data]

        # Build ids if not provided
        if ids is None:
            #start_idx = len(self.collection.get(include=["metadatas", "ids", "documents"])["ids"])
            #ids = [f"doc_{start_idx + i}" for i in range(len(texts))]
            ids = [f"doc_{i}" for i in range(len(texts))]

        # Add to Chroma collection
        self.collection.add(
            documents=texts,
            embeddings=embeddings,
            ids=ids
        )

    def search(self, query: str, k: int = 100) -> List[str]:
        # Create embedding for query (single input -> still pass as list)
        q_resp = mistral_client.embeddings.create(
            model="mistral-embed",
            inputs=[query]
        )
        q_emb = q_resp.data[0].embedding

        result = self.collection.query(
            query_embeddings=[q_emb],
            n_results=k,
            #include=["documents", "distances", "ids"]
            include=["documents", 'distances']
        )

        # result["documents"] is a list-of-lists: one list per query
        return result["documents"][0]
